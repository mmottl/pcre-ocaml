<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Pcre (pcre.Pcre)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../odoc.support/odoc.css"/><meta name="generator" content="odoc 2.4.3"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../index.html">pcre</a> &#x00BB; Pcre</nav><header class="odoc-preamble"><h1>Module <code><span>Pcre</span></code></h1><p>Perl Compatibility Regular Expressions for OCaml</p><p><em>7.5.1 - <a href="https://mmottl.github.io/pcre-ocaml">homepage</a></em></p></header><nav class="odoc-toc"><ul><li><a href="#exceptions">Exceptions</a></li><li><a href="#compilation-and-runtime-flags-and-their-conversion-functions">Compilation and runtime flags and their conversion functions</a></li><li><a href="#information-on-the-pcre-configuration-(build-time-options)">Information on the PCRE-configuration (build-time options)</a></li><li><a href="#information-on-patterns">Information on patterns</a></li><li><a href="#compilation-of-patterns">Compilation of patterns</a></li><li><a href="#subpattern-extraction">Subpattern extraction</a></li><li><a href="#callouts">Callouts</a></li><li><a href="#matching-of-patterns-and-subpattern-extraction">Matching of patterns and subpattern extraction</a></li><li><a href="#string-substitution">String substitution</a></li><li><a href="#splitting">Splitting</a></li><li><a href="#additional-convenience-functions">Additional convenience functions</a></li><li><a href="#unsafe-stuff---use-with-caution!"><b>UNSAFE STUFF - USE WITH CAUTION!</b></a></li></ul></nav><div class="odoc-content"><h2 id="exceptions"><a href="#exceptions" class="anchor"></a>Exceptions</h2><div class="odoc-spec"><div class="spec type anchored" id="type-error"><a href="#type-error" class="anchor"></a><code><span><span class="keyword">type</span> error</span><span> = </span></code><ol><li id="type-error.Partial" class="def variant constructor anchored"><a href="#type-error.Partial" class="anchor"></a><code><span>| </span><span><span class="constructor">Partial</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>String only matched the pattern partially</p><span class="comment-delim">*)</span></div></li><li id="type-error.BadPartial" class="def variant constructor anchored"><a href="#type-error.BadPartial" class="anchor"></a><code><span>| </span><span><span class="constructor">BadPartial</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Pattern contains items that cannot be used together with partial matching.</p><span class="comment-delim">*)</span></div></li><li id="type-error.BadPattern" class="def variant constructor anchored"><a href="#type-error.BadPattern" class="anchor"></a><code><span>| </span><span><span class="constructor">BadPattern</span> <span class="keyword">of</span> string * int</span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>BadPattern (msg, pos)</code> regular expression is malformed. The reason is in <code>msg</code>, the position of the error in the pattern in <code>pos</code>.</p><span class="comment-delim">*)</span></div></li><li id="type-error.BadUTF8" class="def variant constructor anchored"><a href="#type-error.BadUTF8" class="anchor"></a><code><span>| </span><span><span class="constructor">BadUTF8</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>UTF8 string being matched is invalid</p><span class="comment-delim">*)</span></div></li><li id="type-error.BadUTF8Offset" class="def variant constructor anchored"><a href="#type-error.BadUTF8Offset" class="anchor"></a><code><span>| </span><span><span class="constructor">BadUTF8Offset</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Gets raised when a UTF8 string being matched with offset is invalid.</p><span class="comment-delim">*)</span></div></li><li id="type-error.MatchLimit" class="def variant constructor anchored"><a href="#type-error.MatchLimit" class="anchor"></a><code><span>| </span><span><span class="constructor">MatchLimit</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Maximum allowed number of match attempts with backtracking or recursion is reached during matching. ALL FUNCTIONS CALLING THE MATCHING ENGINE MAY RAISE IT!!!</p><span class="comment-delim">*)</span></div></li><li id="type-error.RecursionLimit" class="def variant constructor anchored"><a href="#type-error.RecursionLimit" class="anchor"></a><code><span>| </span><span><span class="constructor">RecursionLimit</span></span></code></li><li id="type-error.WorkspaceSize" class="def variant constructor anchored"><a href="#type-error.WorkspaceSize" class="anchor"></a><code><span>| </span><span><span class="constructor">WorkspaceSize</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Raised by <a href="#val-pcre_dfa_exec"><code>pcre_dfa_exec</code></a> when the provided workspace array is too small. See documention on <a href="#val-pcre_dfa_exec"><code>pcre_dfa_exec</code></a> for details on workspace array sizing.</p><span class="comment-delim">*)</span></div></li><li id="type-error.InternalError" class="def variant constructor anchored"><a href="#type-error.InternalError" class="anchor"></a><code><span>| </span><span><span class="constructor">InternalError</span> <span class="keyword">of</span> string</span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>InternalError msg</code> C-library exhibits unknown/undefined behaviour. The reason is in <code>msg</code>.</p><span class="comment-delim">*)</span></div></li></ol></div></div><div class="odoc-spec"><div class="spec exception anchored" id="exception-Error"><a href="#exception-Error" class="anchor"></a><code><span><span class="keyword">exception</span> </span><span><span class="exception">Error</span> <span class="keyword">of</span> <a href="#type-error">error</a></span></code></div><div class="spec-doc"><p>Exception indicating PCRE errors.</p></div></div><div class="odoc-spec"><div class="spec exception anchored" id="exception-Backtrack"><a href="#exception-Backtrack" class="anchor"></a><code><span><span class="keyword">exception</span> </span><span><span class="exception">Backtrack</span></span></code></div><div class="spec-doc"><p><code>Backtrack</code> used in callout functions to force backtracking.</p></div></div><div class="odoc-spec"><div class="spec exception anchored" id="exception-Regexp_or"><a href="#exception-Regexp_or" class="anchor"></a><code><span><span class="keyword">exception</span> </span><span><span class="exception">Regexp_or</span> <span class="keyword">of</span> string * <a href="#type-error">error</a></span></code></div><div class="spec-doc"><p><code>Regexp_or (pat, error)</code> gets raised for sub-pattern <code>pat</code> by <code>regexp_or</code> if it failed to compile.</p></div></div><h2 id="compilation-and-runtime-flags-and-their-conversion-functions"><a href="#compilation-and-runtime-flags-and-their-conversion-functions" class="anchor"></a>Compilation and runtime flags and their conversion functions</h2><div class="odoc-spec"><div class="spec type anchored" id="type-icflag"><a href="#type-icflag" class="anchor"></a><code><span><span class="keyword">type</span> icflag</span></code></div><div class="spec-doc"><p>Internal representation of compilation flags</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-irflag"><a href="#type-irflag" class="anchor"></a><code><span><span class="keyword">and</span> irflag</span></code></div><div class="spec-doc"><p>Internal representation of runtime flags</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-cflag"><a href="#type-cflag" class="anchor"></a><code><span><span class="keyword">and</span> cflag</span><span> = </span><span>[ </span></code><ol><li id="type-cflag.CASELESS" class="def variant constructor anchored"><a href="#type-cflag.CASELESS" class="anchor"></a><code><span>| </span><span>`CASELESS</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Case insensitive matching</p><span class="comment-delim">*)</span></div></li><li id="type-cflag.MULTILINE" class="def variant constructor anchored"><a href="#type-cflag.MULTILINE" class="anchor"></a><code><span>| </span><span>`MULTILINE</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>'^' and '$' match before/after newlines, not just at the beginning/end of a string</p><span class="comment-delim">*)</span></div></li><li id="type-cflag.DOTALL" class="def variant constructor anchored"><a href="#type-cflag.DOTALL" class="anchor"></a><code><span>| </span><span>`DOTALL</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>'.' matches all characters (newlines, too)</p><span class="comment-delim">*)</span></div></li><li id="type-cflag.EXTENDED" class="def variant constructor anchored"><a href="#type-cflag.EXTENDED" class="anchor"></a><code><span>| </span><span>`EXTENDED</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Ignores whitespace and PERL-comments. Behaves like the '/x'-option in PERL</p><span class="comment-delim">*)</span></div></li><li id="type-cflag.ANCHORED" class="def variant constructor anchored"><a href="#type-cflag.ANCHORED" class="anchor"></a><code><span>| </span><span>`ANCHORED</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Pattern matches only at start of string</p><span class="comment-delim">*)</span></div></li><li id="type-cflag.DOLLAR_ENDONLY" class="def variant constructor anchored"><a href="#type-cflag.DOLLAR_ENDONLY" class="anchor"></a><code><span>| </span><span>`DOLLAR_ENDONLY</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>'$' in pattern matches only at end of string</p><span class="comment-delim">*)</span></div></li><li id="type-cflag.EXTRA" class="def variant constructor anchored"><a href="#type-cflag.EXTRA" class="anchor"></a><code><span>| </span><span>`EXTRA</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Reserved for future extensions of PCRE</p><span class="comment-delim">*)</span></div></li><li id="type-cflag.UNGREEDY" class="def variant constructor anchored"><a href="#type-cflag.UNGREEDY" class="anchor"></a><code><span>| </span><span>`UNGREEDY</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Quantifiers not greedy anymore, only if followed by '?'</p><span class="comment-delim">*)</span></div></li><li id="type-cflag.UTF8" class="def variant constructor anchored"><a href="#type-cflag.UTF8" class="anchor"></a><code><span>| </span><span>`UTF8</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Treats patterns and strings as UTF8 characters.</p><span class="comment-delim">*)</span></div></li><li id="type-cflag.NO_UTF8_CHECK" class="def variant constructor anchored"><a href="#type-cflag.NO_UTF8_CHECK" class="anchor"></a><code><span>| </span><span>`NO_UTF8_CHECK</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Turns off validity checks on UTF8 strings for efficiency reasons. WARNING: invalid UTF8 strings may cause a crash then!</p><span class="comment-delim">*)</span></div></li><li id="type-cflag.NO_AUTO_CAPTURE" class="def variant constructor anchored"><a href="#type-cflag.NO_AUTO_CAPTURE" class="anchor"></a><code><span>| </span><span>`NO_AUTO_CAPTURE</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Disables the use of numbered capturing parentheses</p><span class="comment-delim">*)</span></div></li><li id="type-cflag.AUTO_CALLOUT" class="def variant constructor anchored"><a href="#type-cflag.AUTO_CALLOUT" class="anchor"></a><code><span>| </span><span>`AUTO_CALLOUT</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Automatically inserts callouts with id 255 before each pattern item</p><span class="comment-delim">*)</span></div></li><li id="type-cflag.FIRSTLINE" class="def variant constructor anchored"><a href="#type-cflag.FIRSTLINE" class="anchor"></a><code><span>| </span><span>`FIRSTLINE</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Unanchored patterns must match before/at first NL</p><span class="comment-delim">*)</span></div></li></ol><code><span> ]</span></code></div><div class="spec-doc"><p>Compilation flags</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-cflags"><a href="#val-cflags" class="anchor"></a><code><span><span class="keyword">val</span> cflags : <span><span><a href="#type-cflag">cflag</a> list</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-icflag">icflag</a></span></code></div><div class="spec-doc"><p><code>cflags cflag_list</code> converts a list of compilation flags to their internal representation.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-cflag_list"><a href="#val-cflag_list" class="anchor"></a><code><span><span class="keyword">val</span> cflag_list : <span><a href="#type-icflag">icflag</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-cflag">cflag</a> list</span></span></code></div><div class="spec-doc"><p><code>cflag_list cflags</code> converts internal representation of compilation flags to a list.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-rflag"><a href="#type-rflag" class="anchor"></a><code><span><span class="keyword">type</span> rflag</span><span> = </span><span>[ </span></code><ol><li id="type-rflag.ANCHORED" class="def variant constructor anchored"><a href="#type-rflag.ANCHORED" class="anchor"></a><code><span>| </span><span>`ANCHORED</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Treats pattern as if it were anchored</p><span class="comment-delim">*)</span></div></li><li id="type-rflag.NOTBOL" class="def variant constructor anchored"><a href="#type-rflag.NOTBOL" class="anchor"></a><code><span>| </span><span>`NOTBOL</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Beginning of string is not treated as beginning of line</p><span class="comment-delim">*)</span></div></li><li id="type-rflag.NOTEOL" class="def variant constructor anchored"><a href="#type-rflag.NOTEOL" class="anchor"></a><code><span>| </span><span>`NOTEOL</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>End of string is not treated as end of line</p><span class="comment-delim">*)</span></div></li><li id="type-rflag.NOTEMPTY" class="def variant constructor anchored"><a href="#type-rflag.NOTEMPTY" class="anchor"></a><code><span>| </span><span>`NOTEMPTY</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Empty strings are not considered to be a valid match</p><span class="comment-delim">*)</span></div></li><li id="type-rflag.PARTIAL" class="def variant constructor anchored"><a href="#type-rflag.PARTIAL" class="anchor"></a><code><span>| </span><span>`PARTIAL</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Turns on partial matching</p><span class="comment-delim">*)</span></div></li><li id="type-rflag.DFA_RESTART" class="def variant constructor anchored"><a href="#type-rflag.DFA_RESTART" class="anchor"></a><code><span>| </span><span>`DFA_RESTART</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Causes matching to proceed presuming the subject string is further to one partially matched previously using the same int-array working set. May only be used with <a href="#val-pcre_dfa_exec"><code>pcre_dfa_exec</code></a> or <a href="#val-unsafe_pcre_dfa_exec"><code>unsafe_pcre_dfa_exec</code></a>, and should always be paired with <code>`PARTIAL</code>.</p><span class="comment-delim">*)</span></div></li></ol><code><span> ]</span></code></div><div class="spec-doc"><p>Runtime flags</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-rflags"><a href="#val-rflags" class="anchor"></a><code><span><span class="keyword">val</span> rflags : <span><span><a href="#type-rflag">rflag</a> list</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-irflag">irflag</a></span></code></div><div class="spec-doc"><p><code>rflags rflag_list</code> converts a list of runtime flags to their internal representation.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-rflag_list"><a href="#val-rflag_list" class="anchor"></a><code><span><span class="keyword">val</span> rflag_list : <span><a href="#type-irflag">irflag</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-rflag">rflag</a> list</span></span></code></div><div class="spec-doc"><p><code>rflag_list rflags</code> converts internal representation of runtime flags to a list.</p></div></div><h2 id="information-on-the-pcre-configuration-(build-time-options)"><a href="#information-on-the-pcre-configuration-(build-time-options)" class="anchor"></a>Information on the PCRE-configuration (build-time options)</h2><div class="odoc-spec"><div class="spec value anchored" id="val-version"><a href="#val-version" class="anchor"></a><code><span><span class="keyword">val</span> version : string</span></code></div><div class="spec-doc"><p>Version information</p><p>Version of the PCRE-C-library</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-config_utf8"><a href="#val-config_utf8" class="anchor"></a><code><span><span class="keyword">val</span> config_utf8 : bool</span></code></div><div class="spec-doc"><p>Indicates whether UTF8-support is enabled</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-config_newline"><a href="#val-config_newline" class="anchor"></a><code><span><span class="keyword">val</span> config_newline : char</span></code></div><div class="spec-doc"><p>Character used as newline</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-config_link_size"><a href="#val-config_link_size" class="anchor"></a><code><span><span class="keyword">val</span> config_link_size : int</span></code></div><div class="spec-doc"><p>Number of bytes used for internal linkage of regular expressions</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-config_match_limit"><a href="#val-config_match_limit" class="anchor"></a><code><span><span class="keyword">val</span> config_match_limit : int</span></code></div><div class="spec-doc"><p>Default limit for calls to internal matching function</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-config_match_limit_recursion"><a href="#val-config_match_limit_recursion" class="anchor"></a><code><span><span class="keyword">val</span> config_match_limit_recursion : int</span></code></div><div class="spec-doc"><p>Default limit recursion for calls to internal matching function</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-config_stackrecurse"><a href="#val-config_stackrecurse" class="anchor"></a><code><span><span class="keyword">val</span> config_stackrecurse : bool</span></code></div><div class="spec-doc"><p>Indicates use of stack recursion in matching function</p></div></div><h2 id="information-on-patterns"><a href="#information-on-patterns" class="anchor"></a>Information on patterns</h2><div class="odoc-spec"><div class="spec type anchored" id="type-firstbyte_info"><a href="#type-firstbyte_info" class="anchor"></a><code><span><span class="keyword">type</span> firstbyte_info</span><span> = </span><span>[ </span></code><ol><li id="type-firstbyte_info.Char" class="def variant constructor anchored"><a href="#type-firstbyte_info.Char" class="anchor"></a><code><span>| </span><span>`Char <span class="keyword">of</span> char</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Fixed first character</p><span class="comment-delim">*)</span></div></li><li id="type-firstbyte_info.Start_only" class="def variant constructor anchored"><a href="#type-firstbyte_info.Start_only" class="anchor"></a><code><span>| </span><span>`Start_only</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Pattern matches at beginning and end of newlines</p><span class="comment-delim">*)</span></div></li><li id="type-firstbyte_info.ANCHORED" class="def variant constructor anchored"><a href="#type-firstbyte_info.ANCHORED" class="anchor"></a><code><span>| </span><span>`ANCHORED</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Pattern is anchored</p><span class="comment-delim">*)</span></div></li></ol><code><span> ]</span></code></div><div class="spec-doc"><p>Information on matching of &quot;first chars&quot; in patterns</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-study_stat"><a href="#type-study_stat" class="anchor"></a><code><span><span class="keyword">type</span> study_stat</span><span> = </span><span>[ </span></code><ol><li id="type-study_stat.Not_studied" class="def variant constructor anchored"><a href="#type-study_stat.Not_studied" class="anchor"></a><code><span>| </span><span>`Not_studied</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Pattern has not yet been studied</p><span class="comment-delim">*)</span></div></li><li id="type-study_stat.Studied" class="def variant constructor anchored"><a href="#type-study_stat.Studied" class="anchor"></a><code><span>| </span><span>`Studied</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Pattern has been studied successfully</p><span class="comment-delim">*)</span></div></li><li id="type-study_stat.Optimal" class="def variant constructor anchored"><a href="#type-study_stat.Optimal" class="anchor"></a><code><span>| </span><span>`Optimal</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Pattern could not be improved by studying</p><span class="comment-delim">*)</span></div></li></ol><code><span> ]</span></code></div><div class="spec-doc"><p>Information on the study status of patterns</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-regexp"><a href="#type-regexp" class="anchor"></a><code><span><span class="keyword">type</span> regexp</span></code></div><div class="spec-doc"><p>Compiled regular expressions</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-options"><a href="#val-options" class="anchor"></a><code><span><span class="keyword">val</span> options : <span><a href="#type-regexp">regexp</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-icflag">icflag</a></span></code></div><div class="spec-doc"><p><code>options regexp</code></p><ul class="at-tags"><li class="returns"><span class="at-tag">returns</span> <p>compilation flags of <code>regexp</code>.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-size"><a href="#val-size" class="anchor"></a><code><span><span class="keyword">val</span> size : <span><a href="#type-regexp">regexp</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>size regexp</code></p><ul class="at-tags"><li class="returns"><span class="at-tag">returns</span> <p>memory size of <code>regexp</code>.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-studysize"><a href="#val-studysize" class="anchor"></a><code><span><span class="keyword">val</span> studysize : <span><a href="#type-regexp">regexp</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>studysize regexp</code></p><ul class="at-tags"><li class="returns"><span class="at-tag">returns</span> <p>memory size of study information of <code>regexp</code>.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-capturecount"><a href="#val-capturecount" class="anchor"></a><code><span><span class="keyword">val</span> capturecount : <span><a href="#type-regexp">regexp</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>capturecount regexp</code></p><ul class="at-tags"><li class="returns"><span class="at-tag">returns</span> <p>number of capturing subpatterns in <code>regexp</code>.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-backrefmax"><a href="#val-backrefmax" class="anchor"></a><code><span><span class="keyword">val</span> backrefmax : <span><a href="#type-regexp">regexp</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>backrefmax regexp</code></p><ul class="at-tags"><li class="returns"><span class="at-tag">returns</span> <p>number of highest backreference in <code>regexp</code>.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-namecount"><a href="#val-namecount" class="anchor"></a><code><span><span class="keyword">val</span> namecount : <span><a href="#type-regexp">regexp</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>namecount regexp</code></p><ul class="at-tags"><li class="returns"><span class="at-tag">returns</span> <p>number of named subpatterns in <code>regexp</code>.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-nameentrysize"><a href="#val-nameentrysize" class="anchor"></a><code><span><span class="keyword">val</span> nameentrysize : <span><a href="#type-regexp">regexp</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>nameentrysize regexp</code></p><ul class="at-tags"><li class="returns"><span class="at-tag">returns</span> <p>size of longest name of named subpatterns in <code>regexp</code> + 3.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-names"><a href="#val-names" class="anchor"></a><code><span><span class="keyword">val</span> names : <span><a href="#type-regexp">regexp</a> <span class="arrow">&#45;&gt;</span></span> <span>string array</span></span></code></div><div class="spec-doc"><p><code>names regex</code></p><ul class="at-tags"><li class="returns"><span class="at-tag">returns</span> <p>array of names of named substrings in <code>regexp</code>.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-firstbyte"><a href="#val-firstbyte" class="anchor"></a><code><span><span class="keyword">val</span> firstbyte : <span><a href="#type-regexp">regexp</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-firstbyte_info">firstbyte_info</a></span></code></div><div class="spec-doc"><p><code>firstbyte regexp</code></p><ul class="at-tags"><li class="returns"><span class="at-tag">returns</span> <p>firstbyte info on <code>regexp</code>.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-firsttable"><a href="#val-firsttable" class="anchor"></a><code><span><span class="keyword">val</span> firsttable : <span><a href="#type-regexp">regexp</a> <span class="arrow">&#45;&gt;</span></span> <span>string option</span></span></code></div><div class="spec-doc"><p><code>firsttable regexp</code></p><ul class="at-tags"><li class="returns"><span class="at-tag">returns</span> <p>some 256-bit (32-byte) fixed set table in form of a string for <code>regexp</code> if available, <code>None</code> otherwise.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-lastliteral"><a href="#val-lastliteral" class="anchor"></a><code><span><span class="keyword">val</span> lastliteral : <span><a href="#type-regexp">regexp</a> <span class="arrow">&#45;&gt;</span></span> <span>char option</span></span></code></div><div class="spec-doc"><p><code>lastliteral regexp</code></p><ul class="at-tags"><li class="returns"><span class="at-tag">returns</span> <p>some last matching character of <code>regexp</code> if available, <code>None</code> otherwise.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-study_stat"><a href="#val-study_stat" class="anchor"></a><code><span><span class="keyword">val</span> study_stat : <span><a href="#type-regexp">regexp</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-study_stat">study_stat</a></span></code></div><div class="spec-doc"><p><code>study_stat regexp</code></p><ul class="at-tags"><li class="returns"><span class="at-tag">returns</span> <p>study status of <code>regexp</code>.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-get_stringnumber"><a href="#val-get_stringnumber" class="anchor"></a><code><span><span class="keyword">val</span> get_stringnumber : <span><a href="#type-regexp">regexp</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>get_stringnumber rex name</code></p><ul class="at-tags"><li class="returns"><span class="at-tag">returns</span> <p>the index of the named substring <code>name</code> in regular expression <code>rex</code>. This index can then be used with <code>get_substring</code>.</p></li></ul><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <code>Invalid_arg</code> <p>if there is no such named substring.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-get_match_limit"><a href="#val-get_match_limit" class="anchor"></a><code><span><span class="keyword">val</span> get_match_limit : <span><a href="#type-regexp">regexp</a> <span class="arrow">&#45;&gt;</span></span> <span>int option</span></span></code></div><div class="spec-doc"><p><code>get_match_limit rex</code></p><ul class="at-tags"><li class="returns"><span class="at-tag">returns</span> <p>some match limit of regular expression <code>rex</code> or <code>None</code>.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-get_match_limit_recursion"><a href="#val-get_match_limit_recursion" class="anchor"></a><code><span><span class="keyword">val</span> get_match_limit_recursion : <span><a href="#type-regexp">regexp</a> <span class="arrow">&#45;&gt;</span></span> <span>int option</span></span></code></div><div class="spec-doc"><p><code>get_match_limit_recursion rex</code></p><ul class="at-tags"><li class="returns"><span class="at-tag">returns</span> <p>some recursion match limit of regular expression <code>rex</code> or <code>None</code>.</p></li></ul></div></div><h2 id="compilation-of-patterns"><a href="#compilation-of-patterns" class="anchor"></a>Compilation of patterns</h2><div class="odoc-spec"><div class="spec type anchored" id="type-chtables"><a href="#type-chtables" class="anchor"></a><code><span><span class="keyword">type</span> chtables</span></code></div><div class="spec-doc"><p>Alternative set of char tables for pattern matching</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-maketables"><a href="#val-maketables" class="anchor"></a><code><span><span class="keyword">val</span> maketables : <span>unit <span class="arrow">&#45;&gt;</span></span> <a href="#type-chtables">chtables</a></span></code></div><div class="spec-doc"><p>Generates new set of char tables for the current locale.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-regexp"><a href="#val-regexp" class="anchor"></a><code><span><span class="keyword">val</span> regexp : 
  <span><span class="optlabel">?study</span>:bool <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?jit_compile</span>:bool <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?limit</span>:int <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?limit_recursion</span>:int <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?iflags</span>:<a href="#type-icflag">icflag</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?flags</span>:<span><a href="#type-cflag">cflag</a> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?chtables</span>:<a href="#type-chtables">chtables</a> <span class="arrow">&#45;&gt;</span></span>
  <span>string <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-regexp">regexp</a></span></code></div><div class="spec-doc"><p><code>regexp ?jit_compile ?study ?limit ?limit_recursion ?iflags ?flags
    ?chtables pattern</code> compiles <code>pattern</code> with <code>flags</code> when given, with <code>iflags</code> otherwise, and with char tables <code>chtables</code>. If <code>study</code> is true, then the resulting regular expression will be studied. If <code>jit_compile</code> is true, studying will also perform JIT-compilation of the pattern. If <code>limit</code> is specified, this sets a limit to the amount of recursion and backtracking (only lower than the builtin default!). If this limit is exceeded, <code>MatchLimit</code> will be raised during matching.</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">study</span> <p>default = true</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">jit_compile</span> <p>default = false</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">limit</span> <p>default = no extra limit other than default</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">limit_recursion</span> <p>default = no extra limit_recursion other than default</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">iflags</span> <p>default = no extra flags</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">flags</span> <p>default = ignored</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">chtables</span> <p>default = builtin char tables</p></li></ul><ul class="at-tags"><li class="returns"><span class="at-tag">returns</span> <p>the regular expression.</p><p>For detailed documentation on how you can specify PERL-style regular expressions (= patterns), please consult the PCRE-documentation (&quot;man pcrepattern&quot;) or PERL-manuals.</p></li></ul><ul class="at-tags"><li class="see"><span class="at-tag">see</span> <a href="http://www.perl.com" class="value">http://www.perl.com</a> <p>www.perl.com</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-regexp_or"><a href="#val-regexp_or" class="anchor"></a><code><span><span class="keyword">val</span> regexp_or : 
  <span><span class="optlabel">?study</span>:bool <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?jit_compile</span>:bool <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?limit</span>:int <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?limit_recursion</span>:int <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?iflags</span>:<a href="#type-icflag">icflag</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?flags</span>:<span><a href="#type-cflag">cflag</a> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?chtables</span>:<a href="#type-chtables">chtables</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>string list</span> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-regexp">regexp</a></span></code></div><div class="spec-doc"><p><code>regexp_or ?study ?limit ?limit_recursion ?iflags ?flags ?chtables patterns</code> like <a href="#val-regexp"><code>regexp</code></a>, but combines <code>patterns</code> as alternatives (or-patterns) into one regular expression.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-quote"><a href="#val-quote" class="anchor"></a><code><span><span class="keyword">val</span> quote : <span>string <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>quote str</code></p><ul class="at-tags"><li class="returns"><span class="at-tag">returns</span> <p>the quoted string of <code>str</code>.</p></li></ul></div></div><h2 id="subpattern-extraction"><a href="#subpattern-extraction" class="anchor"></a>Subpattern extraction</h2><div class="odoc-spec"><div class="spec type anchored" id="type-substrings"><a href="#type-substrings" class="anchor"></a><code><span><span class="keyword">type</span> substrings</span></code></div><div class="spec-doc"><p>Information on substrings after pattern matching</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-get_subject"><a href="#val-get_subject" class="anchor"></a><code><span><span class="keyword">val</span> get_subject : <span><a href="#type-substrings">substrings</a> <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>get_subject substrings</code></p><ul class="at-tags"><li class="returns"><span class="at-tag">returns</span> <p>the subject string of <code>substrings</code>.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-num_of_subs"><a href="#val-num_of_subs" class="anchor"></a><code><span><span class="keyword">val</span> num_of_subs : <span><a href="#type-substrings">substrings</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>num_of_subs substrings</code></p><ul class="at-tags"><li class="returns"><span class="at-tag">returns</span> <p>number of strings in <code>substrings</code> (whole match inclusive).</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-get_substring"><a href="#val-get_substring" class="anchor"></a><code><span><span class="keyword">val</span> get_substring : <span><a href="#type-substrings">substrings</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>get_substring substrings n</code></p><ul class="at-tags"><li class="returns"><span class="at-tag">returns</span> <p>the <code>n</code>th substring (0 is whole match) of <code>substrings</code>.</p></li></ul><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <code>Invalid_argument</code> <p>if <code>n</code> is not in the range of the number of substrings.</p></li></ul><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <code>Not_found</code> <p>if the corresponding subpattern did not capture a substring.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-get_substring_ofs"><a href="#val-get_substring_ofs" class="anchor"></a><code><span><span class="keyword">val</span> get_substring_ofs : <span><a href="#type-substrings">substrings</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> int * int</span></code></div><div class="spec-doc"><p><code>get_substring_ofs substrings n</code></p><ul class="at-tags"><li class="returns"><span class="at-tag">returns</span> <p>the offset tuple of the <code>n</code>th substring of <code>substrings</code> (0 is whole match).</p></li></ul><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <code>Invalid_argument</code> <p>if <code>n</code> is not in the range of the number of substrings.</p></li></ul><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <code>Not_found</code> <p>if the corresponding subpattern did not capture a substring.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-get_substrings"><a href="#val-get_substrings" class="anchor"></a><code><span><span class="keyword">val</span> get_substrings : <span><span class="optlabel">?full_match</span>:bool <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-substrings">substrings</a> <span class="arrow">&#45;&gt;</span></span> <span>string array</span></span></code></div><div class="spec-doc"><p><code>get_substrings ?full_match substrings</code></p><ul class="at-tags"><li class="returns"><span class="at-tag">returns</span> <p>the array of substrings in <code>substrings</code>. It includes the full match at index 0 when <code>full_match</code> is <code>true</code>, the captured substrings only when it is <code>false</code>. If a subpattern did not capture a substring, the empty string is returned in the corresponding position instead.</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">full_match</span> <p>default = true</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-get_opt_substrings"><a href="#val-get_opt_substrings" class="anchor"></a><code><span><span class="keyword">val</span> get_opt_substrings : <span><span class="optlabel">?full_match</span>:bool <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-substrings">substrings</a> <span class="arrow">&#45;&gt;</span></span> <span><span>string option</span> array</span></span></code></div><div class="spec-doc"><p><code>get_opt_substrings ?full_match substrings</code></p><ul class="at-tags"><li class="returns"><span class="at-tag">returns</span> <p>the array of optional substrings in <code>substrings</code>. It includes <code>Some full_match_str</code> at index 0 when <code>full_match</code> is <code>true</code>, <code>Some captured_substrings</code> only when it is <code>false</code>. If a subpattern did not capture a substring, <code>None</code> is returned in the corresponding position instead.</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">full_match</span> <p>default = true</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-get_named_substring"><a href="#val-get_named_substring" class="anchor"></a><code><span><span class="keyword">val</span> get_named_substring : <span><a href="#type-regexp">regexp</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-substrings">substrings</a> <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>get_named_substring rex name substrings</code></p><ul class="at-tags"><li class="returns"><span class="at-tag">returns</span> <p>the named substring <code>name</code> in regular expression <code>rex</code> and <code>substrings</code>.</p></li></ul><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <code>Invalid_argument</code> <p>if there is no such named substring.</p></li></ul><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <code>Not_found</code> <p>if the corresponding subpattern did not capture a substring.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-get_named_substring_ofs"><a href="#val-get_named_substring_ofs" class="anchor"></a><code><span><span class="keyword">val</span> get_named_substring_ofs : <span><a href="#type-regexp">regexp</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-substrings">substrings</a> <span class="arrow">&#45;&gt;</span></span> int * int</span></code></div><div class="spec-doc"><p><code>get_named_substring_ofs rex name substrings</code></p><ul class="at-tags"><li class="returns"><span class="at-tag">returns</span> <p>the offset tuple of the named substring <code>name</code> in regular expression <code>rex</code> and <code>substrings</code>.</p></li></ul><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <code>Invalid_argument</code> <p>if there is no such named substring.</p></li></ul><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <code>Not_found</code> <p>if the corresponding subpattern did not capture a substring.</p></li></ul></div></div><h2 id="callouts"><a href="#callouts" class="anchor"></a>Callouts</h2><div class="odoc-spec"><div class="spec type anchored" id="type-callout_data"><a href="#type-callout_data" class="anchor"></a><code><span><span class="keyword">type</span> callout_data</span><span> = </span><span>{</span></code><ol><li id="type-callout_data.callout_number" class="def record field anchored"><a href="#type-callout_data.callout_number" class="anchor"></a><code><span>callout_number : int;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Callout number</p><span class="comment-delim">*)</span></div></li><li id="type-callout_data.substrings" class="def record field anchored"><a href="#type-callout_data.substrings" class="anchor"></a><code><span>substrings : <a href="#type-substrings">substrings</a>;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Substrings matched so far</p><span class="comment-delim">*)</span></div></li><li id="type-callout_data.start_match" class="def record field anchored"><a href="#type-callout_data.start_match" class="anchor"></a><code><span>start_match : int;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Subject start offset of current match attempt</p><span class="comment-delim">*)</span></div></li><li id="type-callout_data.current_position" class="def record field anchored"><a href="#type-callout_data.current_position" class="anchor"></a><code><span>current_position : int;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Subject offset of current match pointer</p><span class="comment-delim">*)</span></div></li><li id="type-callout_data.capture_top" class="def record field anchored"><a href="#type-callout_data.capture_top" class="anchor"></a><code><span>capture_top : int;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Number of the highest captured substring so far</p><span class="comment-delim">*)</span></div></li><li id="type-callout_data.capture_last" class="def record field anchored"><a href="#type-callout_data.capture_last" class="anchor"></a><code><span>capture_last : int;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Number of the most recently captured substring</p><span class="comment-delim">*)</span></div></li><li id="type-callout_data.pattern_position" class="def record field anchored"><a href="#type-callout_data.pattern_position" class="anchor"></a><code><span>pattern_position : int;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Offset of next match item in pattern string</p><span class="comment-delim">*)</span></div></li><li id="type-callout_data.next_item_length" class="def record field anchored"><a href="#type-callout_data.next_item_length" class="anchor"></a><code><span>next_item_length : int;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Length of next match item in pattern string</p><span class="comment-delim">*)</span></div></li></ol><code><span>}</span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-callout"><a href="#type-callout" class="anchor"></a><code><span><span class="keyword">type</span> callout</span><span> = <span><a href="#type-callout_data">callout_data</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Type of callout functions</p><p>Callouts are referred to in patterns as &quot;(?Cn)&quot; where &quot;n&quot; is a <code>callout_number</code> ranging from 0 to 255. Substrings captured so far are accessible as usual via <code>substrings</code>. You will have to consider <code>capture_top</code> and <code>capture_last</code> to know about the current state of valid substrings.</p><p>By raising exception <code>Backtrack</code> within a callout function, the user can force the pattern matching engine to backtrack to other possible solutions. Other exceptions will terminate matching immediately and return control to OCaml.</p></div></div><h2 id="matching-of-patterns-and-subpattern-extraction"><a href="#matching-of-patterns-and-subpattern-extraction" class="anchor"></a>Matching of patterns and subpattern extraction</h2><div class="odoc-spec"><div class="spec value anchored" id="val-pcre_exec"><a href="#val-pcre_exec" class="anchor"></a><code><span><span class="keyword">val</span> pcre_exec : 
  <span><span class="optlabel">?iflags</span>:<a href="#type-irflag">irflag</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?flags</span>:<span><a href="#type-rflag">rflag</a> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?rex</span>:<a href="#type-regexp">regexp</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?pat</span>:string <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?pos</span>:int <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?callout</span>:<a href="#type-callout">callout</a> <span class="arrow">&#45;&gt;</span></span>
  <span>string <span class="arrow">&#45;&gt;</span></span>
  <span>int array</span></span></code></div><div class="spec-doc"><p><code>pcre_exec ?iflags ?flags ?rex ?pat ?pos ?callout subj</code></p><ul class="at-tags"><li class="returns"><span class="at-tag">returns</span> <p>an array of offsets that describe the position of matched subpatterns in the string <code>subj</code> starting at position <code>pos</code> with pattern <code>pat</code> when given, regular expression <code>rex</code> otherwise. The array also contains additional workspace needed by the match engine. Uses <code>flags</code> when given, the precompiled <code>iflags</code> otherwise. Callouts are handled by <code>callout</code>.</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">iflags</span> <p>default = no extra flags</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">flags</span> <p>default = ignored</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">rex</span> <p>default = matches whitespace</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">pat</span> <p>default = ignored</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">pos</span> <p>default = 0</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">callout</span> <p>default = ignore callouts</p></li></ul><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <code>Not_found</code> <p>if pattern does not match.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pcre_dfa_exec"><a href="#val-pcre_dfa_exec" class="anchor"></a><code><span><span class="keyword">val</span> pcre_dfa_exec : 
  <span><span class="optlabel">?iflags</span>:<a href="#type-irflag">irflag</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?flags</span>:<span><a href="#type-rflag">rflag</a> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?rex</span>:<a href="#type-regexp">regexp</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?pat</span>:string <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?pos</span>:int <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?callout</span>:<a href="#type-callout">callout</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?workspace</span>:<span>int array</span> <span class="arrow">&#45;&gt;</span></span>
  <span>string <span class="arrow">&#45;&gt;</span></span>
  <span>int array</span></span></code></div><div class="spec-doc"><p><code>pcre_dfa_exec ?iflags ?flags ?rex ?pat ?pos ?callout ?workspace subj</code> invokes the &quot;alternative&quot; DFA matching function.</p><ul class="at-tags"><li class="returns"><span class="at-tag">returns</span> <p>an array of offsets that describe the position of matched subpatterns in the string <code>subj</code> starting at position <code>pos</code> with pattern <code>pat</code> when given, regular expression <code>rex</code> otherwise. The array also contains additional workspace needed by the match engine. Uses <code>flags</code> when given, the precompiled <code>iflags</code> otherwise. Requires a sufficiently-large <code>workspace</code> array. Callouts are handled by <code>callout</code>.</p><p>Note that the returned array of offsets are quite different from those returned by <a href="#val-pcre_exec"><code>pcre_exec</code></a> et al. The motivating use case for the DFA match function is to be able to restart a partial match with N additional input segments. Because the match function/workspace does not store segments seen previously, the offsets returned when a match completes will refer only to the matching portion of the last subject string provided. Thus, returned offsets from this function should not be used to support extracting captured submatches. If you need to capture submatches from a series of inputs incrementally matched with this function, you'll need to concatenate those inputs that yield a successful match here and re-run the same pattern against that single subject string.</p><p>Aside from an absolute minimum of <code>20</code>, PCRE does not provide any guidance regarding the size of workspace array needed by any given pattern. Therefore, it is wise to appropriately handle the possible <code>WorkspaceSize</code> error. If raised, you can allocate a new, larger workspace array and begin the DFA matching process again.</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">iflags</span> <p>default = no extra flags</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">flags</span> <p>default = ignored</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">rex</span> <p>default = matches whitespace</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">pat</span> <p>default = ignored</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">pos</span> <p>default = 0</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">callout</span> <p>default = ignore callouts</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">workspace</span> <p>default = fresh array of length <code>20</code></p></li></ul><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <code>Not_found</code> <p>if the pattern match has failed</p></li></ul><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <a href="#exception-Error"><code>Error</code></a> <p>Partial if the pattern has matched partially; a subsequent exec call with the same pattern and workspace (adding the <code>DFA_RESTART</code> flag) be made to either further advance or complete the partial match.</p></li></ul><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <a href="#exception-Error"><code>Error</code></a> <p>WorkspaceSize if the workspace array is too small to accommodate the DFA state required by the supplied pattern</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-exec"><a href="#val-exec" class="anchor"></a><code><span><span class="keyword">val</span> exec : 
  <span><span class="optlabel">?iflags</span>:<a href="#type-irflag">irflag</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?flags</span>:<span><a href="#type-rflag">rflag</a> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?rex</span>:<a href="#type-regexp">regexp</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?pat</span>:string <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?pos</span>:int <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?callout</span>:<a href="#type-callout">callout</a> <span class="arrow">&#45;&gt;</span></span>
  <span>string <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-substrings">substrings</a></span></code></div><div class="spec-doc"><p><code>exec ?iflags ?flags ?rex ?pat ?pos ?callout subj</code></p><ul class="at-tags"><li class="returns"><span class="at-tag">returns</span> <p>substring information on string <code>subj</code> starting at position <code>pos</code> with pattern <code>pat</code> when given, regular expression <code>rex</code> otherwise. Uses <code>flags</code> when given, the precompiled <code>iflags</code> otherwise. Callouts are handled by <code>callout</code>.</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">iflags</span> <p>default = no extra flags</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">flags</span> <p>default = ignored</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">rex</span> <p>default = matches whitespace</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">pat</span> <p>default = ignored</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">pos</span> <p>default = 0</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">callout</span> <p>default = ignore callouts</p></li></ul><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <code>Not_found</code> <p>if pattern does not match.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-exec_all"><a href="#val-exec_all" class="anchor"></a><code><span><span class="keyword">val</span> exec_all : 
  <span><span class="optlabel">?iflags</span>:<a href="#type-irflag">irflag</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?flags</span>:<span><a href="#type-rflag">rflag</a> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?rex</span>:<a href="#type-regexp">regexp</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?pat</span>:string <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?pos</span>:int <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?callout</span>:<a href="#type-callout">callout</a> <span class="arrow">&#45;&gt;</span></span>
  <span>string <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-substrings">substrings</a> array</span></span></code></div><div class="spec-doc"><p><code>exec_all ?iflags ?flags ?rex ?pat ?pos ?callout subj</code></p><ul class="at-tags"><li class="returns"><span class="at-tag">returns</span> <p>an array of substring information of all matching substrings in string <code>subj</code> starting at position <code>pos</code> with pattern <code>pat</code> when given, regular expression <code>rex</code> otherwise. Uses <code>flags</code> when given, the precompiled <code>iflags</code> otherwise. Callouts are handled by <code>callout</code>.</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">iflags</span> <p>default = no extra flags</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">flags</span> <p>default = ignored</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">rex</span> <p>default = matches whitespace</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">pat</span> <p>default = ignored</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">pos</span> <p>default = 0</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">callout</span> <p>default = ignore callouts</p></li></ul><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <code>Not_found</code> <p>if pattern does not match.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-next_match"><a href="#val-next_match" class="anchor"></a><code><span><span class="keyword">val</span> next_match : 
  <span><span class="optlabel">?iflags</span>:<a href="#type-irflag">irflag</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?flags</span>:<span><a href="#type-rflag">rflag</a> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?rex</span>:<a href="#type-regexp">regexp</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?pat</span>:string <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?pos</span>:int <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?callout</span>:<a href="#type-callout">callout</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-substrings">substrings</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-substrings">substrings</a></span></code></div><div class="spec-doc"><p><code>next_match ?iflags ?flags ?rex ?pat ?pos ?callout substrs</code></p><ul class="at-tags"><li class="returns"><span class="at-tag">returns</span> <p>substring information on the match that follows on the last match denoted by <code>substrs</code>, jumping over <code>pos</code> characters (also backwards!), using pattern <code>pat</code> when given, regular expression <code>rex</code> otherwise. Uses <code>flags</code> when given, the precompiled <code>iflags</code> otherwise. Callouts are handled by <code>callout</code>.</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">iflags</span> <p>default = no extra flags</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">flags</span> <p>default = ignored</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">rex</span> <p>default = matches whitespace</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">pat</span> <p>default = ignored</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">pos</span> <p>default = 0</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">callout</span> <p>default = ignore callouts</p></li></ul><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <code>Not_found</code> <p>if pattern does not match.</p></li></ul><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <code>Invalid_arg</code> <p>if <code>pos</code> let matching start outside of the subject string.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-extract"><a href="#val-extract" class="anchor"></a><code><span><span class="keyword">val</span> extract : 
  <span><span class="optlabel">?iflags</span>:<a href="#type-irflag">irflag</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?flags</span>:<span><a href="#type-rflag">rflag</a> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?rex</span>:<a href="#type-regexp">regexp</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?pat</span>:string <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?pos</span>:int <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?full_match</span>:bool <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?callout</span>:<a href="#type-callout">callout</a> <span class="arrow">&#45;&gt;</span></span>
  <span>string <span class="arrow">&#45;&gt;</span></span>
  <span>string array</span></span></code></div><div class="spec-doc"><p><code>extract ?iflags ?flags ?rex ?pat ?pos ?full_match ?callout subj</code></p><ul class="at-tags"><li class="returns"><span class="at-tag">returns</span> <p>the array of substrings that match <code>subj</code> starting at position <code>pos</code>, using pattern <code>pat</code> when given, regular expression <code>rex</code> otherwise. Uses <code>flags</code> when given, the precompiled <code>iflags</code> otherwise. It includes the full match at index 0 when <code>full_match</code> is <code>true</code>, the captured substrings only when it is <code>false</code>. Callouts are handled by <code>callout</code>. If a subpattern did not capture a substring, the empty string is returned in the corresponding position instead.</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">iflags</span> <p>default = no extra flags</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">flags</span> <p>default = ignored</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">rex</span> <p>default = matches whitespace</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">pat</span> <p>default = ignored</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">pos</span> <p>default = 0</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">full_match</span> <p>default = true</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">callout</span> <p>default = ignore callouts</p></li></ul><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <code>Not_found</code> <p>if pattern does not match.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-extract_opt"><a href="#val-extract_opt" class="anchor"></a><code><span><span class="keyword">val</span> extract_opt : 
  <span><span class="optlabel">?iflags</span>:<a href="#type-irflag">irflag</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?flags</span>:<span><a href="#type-rflag">rflag</a> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?rex</span>:<a href="#type-regexp">regexp</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?pat</span>:string <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?pos</span>:int <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?full_match</span>:bool <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?callout</span>:<a href="#type-callout">callout</a> <span class="arrow">&#45;&gt;</span></span>
  <span>string <span class="arrow">&#45;&gt;</span></span>
  <span><span>string option</span> array</span></span></code></div><div class="spec-doc"><p><code>extract_opt ?iflags ?flags ?rex ?pat ?pos ?full_match ?callout subj</code></p><ul class="at-tags"><li class="returns"><span class="at-tag">returns</span> <p>the array of optional substrings that match <code>subj</code> starting at position <code>pos</code>, using pattern <code>pat</code> when given, regular expression <code>rex</code> otherwise. Uses <code>flags</code> when given, the precompiled <code>iflags</code> otherwise. It includes <code>Some full_match_str</code> at index 0 when <code>full_match</code> is <code>true</code>, <code>Some captured-substrings</code> only when it is <code>false</code>. Callouts are handled by <code>callout</code>. If a subpattern did not capture a substring, <code>None</code> is returned in the corresponding position instead.</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">iflags</span> <p>default = no extra flags</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">flags</span> <p>default = ignored</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">rex</span> <p>default = matches whitespace</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">pat</span> <p>default = ignored</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">pos</span> <p>default = 0</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">full_match</span> <p>default = true</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">callout</span> <p>default = ignore callouts</p></li></ul><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <code>Not_found</code> <p>if pattern does not match.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-extract_all"><a href="#val-extract_all" class="anchor"></a><code><span><span class="keyword">val</span> extract_all : 
  <span><span class="optlabel">?iflags</span>:<a href="#type-irflag">irflag</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?flags</span>:<span><a href="#type-rflag">rflag</a> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?rex</span>:<a href="#type-regexp">regexp</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?pat</span>:string <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?pos</span>:int <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?full_match</span>:bool <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?callout</span>:<a href="#type-callout">callout</a> <span class="arrow">&#45;&gt;</span></span>
  <span>string <span class="arrow">&#45;&gt;</span></span>
  <span><span>string array</span> array</span></span></code></div><div class="spec-doc"><p><code>extract_all ?iflags ?flags ?rex ?pat ?pos ?full_match ?callout subj</code></p><ul class="at-tags"><li class="returns"><span class="at-tag">returns</span> <p>an array of arrays of all matching substrings that match <code>subj</code> starting at position <code>pos</code>, using pattern <code>pat</code> when given, regular expression <code>rex</code> otherwise. Uses <code>flags</code> when given, the precompiled <code>iflags</code> otherwise. It includes the full match at index 0 of the extracted string arrays when <code>full_match</code> is <code>true</code>, the captured substrings only when it is <code>false</code>. Callouts are handled by <code>callout</code>.</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">iflags</span> <p>default = no extra flags</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">flags</span> <p>default = ignored</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">rex</span> <p>default = matches whitespace</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">pat</span> <p>default = ignored</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">pos</span> <p>default = 0</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">full_match</span> <p>default = true</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">callout</span> <p>default = ignore callouts</p></li></ul><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <code>Not_found</code> <p>if pattern does not match.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-extract_all_opt"><a href="#val-extract_all_opt" class="anchor"></a><code><span><span class="keyword">val</span> extract_all_opt : 
  <span><span class="optlabel">?iflags</span>:<a href="#type-irflag">irflag</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?flags</span>:<span><a href="#type-rflag">rflag</a> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?rex</span>:<a href="#type-regexp">regexp</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?pat</span>:string <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?pos</span>:int <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?full_match</span>:bool <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?callout</span>:<a href="#type-callout">callout</a> <span class="arrow">&#45;&gt;</span></span>
  <span>string <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>string option</span> array</span> array</span></span></code></div><div class="spec-doc"><p><code>extract_all_opt
      ?iflags ?flags ?rex ?pat ?pos ?full_match ?callout subj</code></p><ul class="at-tags"><li class="returns"><span class="at-tag">returns</span> <p>an array of arrays of all optional matching substrings that match <code>subj</code> starting at position <code>pos</code>, using pattern <code>pat</code> when given, regular expression <code>rex</code> otherwise. Uses <code>flags</code> when given, the precompiled <code>iflags</code> otherwise. It includes <code>Some full_match_str</code> at index 0 of the extracted string arrays when <code>full_match</code> is <code>true</code>, <code>Some captured_substrings</code> only when it is <code>false</code>. Callouts are handled by <code>callout</code>. If a subpattern did not capture a substring, <code>None</code> is returned in the corresponding position instead.</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">iflags</span> <p>default = no extra flags</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">flags</span> <p>default = ignored</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">rex</span> <p>default = matches whitespace</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">pat</span> <p>default = ignored</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">pos</span> <p>default = 0</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">full_match</span> <p>default = true</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">callout</span> <p>default = ignore callouts</p></li></ul><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <code>Not_found</code> <p>if pattern does not match.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pmatch"><a href="#val-pmatch" class="anchor"></a><code><span><span class="keyword">val</span> pmatch : 
  <span><span class="optlabel">?iflags</span>:<a href="#type-irflag">irflag</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?flags</span>:<span><a href="#type-rflag">rflag</a> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?rex</span>:<a href="#type-regexp">regexp</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?pat</span>:string <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?pos</span>:int <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?callout</span>:<a href="#type-callout">callout</a> <span class="arrow">&#45;&gt;</span></span>
  <span>string <span class="arrow">&#45;&gt;</span></span>
  bool</span></code></div><div class="spec-doc"><p><code>pmatch ?iflags ?flags ?rex ?pat ?pos ?callout subj</code></p><ul class="at-tags"><li class="returns"><span class="at-tag">returns</span> <p><code>true</code> if <code>subj</code> is matched by pattern <code>pat</code> when given, regular expression <code>rex</code> otherwise, starting at position <code>pos</code>. Uses <code>flags</code> when given, the precompiled <code>iflags</code> otherwise. Callouts are handled by <code>callout</code>.</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">iflags</span> <p>default = no extra flags</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">flags</span> <p>default = ignored</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">rex</span> <p>default = matches whitespace</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">pat</span> <p>default = ignored</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">pos</span> <p>default = 0</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">callout</span> <p>default = ignore callouts</p></li></ul></div></div><h2 id="string-substitution"><a href="#string-substitution" class="anchor"></a>String substitution</h2><div class="odoc-spec"><div class="spec type anchored" id="type-substitution"><a href="#type-substitution" class="anchor"></a><code><span><span class="keyword">type</span> substitution</span></code></div><div class="spec-doc"><p>Information on substitution patterns</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-subst"><a href="#val-subst" class="anchor"></a><code><span><span class="keyword">val</span> subst : <span>string <span class="arrow">&#45;&gt;</span></span> <a href="#type-substitution">substitution</a></span></code></div><div class="spec-doc"><p><code>subst str</code> converts the string <code>str</code> representing a substitution pattern to the internal representation</p><p>The contents of the substitution string <code>str</code> can be normal text mixed with any of the following (mostly as in PERL):</p><ul><li><em>$[0-9]+</em> - a &quot;$&quot; immediately followed by an arbitrary number. &quot;$0&quot; stands for the name of the executable, any other number for the n-th backreference.</li><li><em>$&amp;</em> - the whole matched pattern</li><li><em>$`</em> - the text before the match</li><li><em>$'</em> - the text after the match</li><li><em>$+</em> - the last group that matched</li><li><em>$$</em> - a single &quot;$&quot;</li><li><em>$!</em> - delimiter which does not appear in the substitution. Can be used to part &quot;$<code>0-9</code>+&quot; from an immediately following other number.</li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-replace"><a href="#val-replace" class="anchor"></a><code><span><span class="keyword">val</span> replace : 
  <span><span class="optlabel">?iflags</span>:<a href="#type-irflag">irflag</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?flags</span>:<span><a href="#type-rflag">rflag</a> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?rex</span>:<a href="#type-regexp">regexp</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?pat</span>:string <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?pos</span>:int <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?itempl</span>:<a href="#type-substitution">substitution</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?templ</span>:string <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?callout</span>:<a href="#type-callout">callout</a> <span class="arrow">&#45;&gt;</span></span>
  <span>string <span class="arrow">&#45;&gt;</span></span>
  string</span></code></div><div class="spec-doc"><p><code>replace ?iflags ?flags ?rex ?pat ?pos ?itempl ?templ ?callout subj</code> replaces all substrings of <code>subj</code> matching pattern <code>pat</code> when given, regular expression <code>rex</code> otherwise, starting at position <code>pos</code> with the substitution string <code>templ</code> when given, <code>itempl</code> otherwise. Uses <code>flags</code> when given, the precompiled <code>iflags</code> otherwise. Callouts are handled by <code>callout</code>.</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">iflags</span> <p>default = no extra flags</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">flags</span> <p>default = ignored</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">rex</span> <p>default = matches whitespace</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">pat</span> <p>default = ignored</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">pos</span> <p>default = 0</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">itempl</span> <p>default = empty string</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">templ</span> <p>default = ignored</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">callout</span> <p>default = ignore callouts</p></li></ul><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <code>Failure</code> <p>if there are backreferences to nonexistent subpatterns.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-qreplace"><a href="#val-qreplace" class="anchor"></a><code><span><span class="keyword">val</span> qreplace : 
  <span><span class="optlabel">?iflags</span>:<a href="#type-irflag">irflag</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?flags</span>:<span><a href="#type-rflag">rflag</a> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?rex</span>:<a href="#type-regexp">regexp</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?pat</span>:string <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?pos</span>:int <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?templ</span>:string <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?callout</span>:<a href="#type-callout">callout</a> <span class="arrow">&#45;&gt;</span></span>
  <span>string <span class="arrow">&#45;&gt;</span></span>
  string</span></code></div><div class="spec-doc"><p><code>qreplace ?iflags ?flags ?rex ?pat ?pos ?templ ?callout subj</code> replaces all substrings of <code>subj</code> matching pattern <code>pat</code> when given, regular expression <code>rex</code> otherwise, starting at position <code>pos</code> with the string <code>templ</code>. Uses <code>flags</code> when given, the precompiled <code>iflags</code> otherwise. Callouts are handled by <code>callout</code>.</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">iflags</span> <p>default = no extra flags</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">flags</span> <p>default = ignored</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">rex</span> <p>default = matches whitespace</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">pat</span> <p>default = ignored</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">pos</span> <p>default = 0</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">templ</span> <p>default = ignored</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">callout</span> <p>default = ignore callouts</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-substitute_substrings"><a href="#val-substitute_substrings" class="anchor"></a><code><span><span class="keyword">val</span> substitute_substrings : 
  <span><span class="optlabel">?iflags</span>:<a href="#type-irflag">irflag</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?flags</span>:<span><a href="#type-rflag">rflag</a> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?rex</span>:<a href="#type-regexp">regexp</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?pat</span>:string <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?pos</span>:int <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?callout</span>:<a href="#type-callout">callout</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">subst</span>:<span>(<span><a href="#type-substrings">substrings</a> <span class="arrow">&#45;&gt;</span></span> string)</span> <span class="arrow">&#45;&gt;</span></span>
  <span>string <span class="arrow">&#45;&gt;</span></span>
  string</span></code></div><div class="spec-doc"><p><code>substitute_substrings ?iflags ?flags ?rex ?pat ?pos ?callout ~subst subj</code> replaces all substrings of <code>subj</code> matching pattern <code>pat</code> when given, regular expression <code>rex</code> otherwise, starting at position <code>pos</code> with the result of function <code>subst</code> applied to the substrings of the match. Uses <code>flags</code> when given, the precompiled <code>iflags</code> otherwise. Callouts are handled by <code>callout</code>.</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">iflags</span> <p>default = no extra flags</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">flags</span> <p>default = ignored</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">rex</span> <p>default = matches whitespace</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">pat</span> <p>default = ignored</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">pos</span> <p>default = 0</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">callout</span> <p>default = ignore callouts</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-substitute"><a href="#val-substitute" class="anchor"></a><code><span><span class="keyword">val</span> substitute : 
  <span><span class="optlabel">?iflags</span>:<a href="#type-irflag">irflag</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?flags</span>:<span><a href="#type-rflag">rflag</a> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?rex</span>:<a href="#type-regexp">regexp</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?pat</span>:string <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?pos</span>:int <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?callout</span>:<a href="#type-callout">callout</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">subst</span>:<span>(<span>string <span class="arrow">&#45;&gt;</span></span> string)</span> <span class="arrow">&#45;&gt;</span></span>
  <span>string <span class="arrow">&#45;&gt;</span></span>
  string</span></code></div><div class="spec-doc"><p><code>substitute ?iflags ?flags ?rex ?pat ?pos ?callout ~subst subj</code> replaces all substrings of <code>subj</code> matching pattern <code>pat</code> when given, regular expression <code>rex</code> otherwise, starting at position <code>pos</code> with the result of function <code>subst</code> applied to the match. Uses <code>flags</code> when given, the precompiled <code>iflags</code> otherwise. Callouts are handled by <code>callout</code>.</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">iflags</span> <p>default = no extra flags</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">flags</span> <p>default = ignored</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">rex</span> <p>default = matches whitespace</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">pat</span> <p>default = ignored</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">pos</span> <p>default = 0</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">callout</span> <p>default = ignore callouts</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-replace_first"><a href="#val-replace_first" class="anchor"></a><code><span><span class="keyword">val</span> replace_first : 
  <span><span class="optlabel">?iflags</span>:<a href="#type-irflag">irflag</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?flags</span>:<span><a href="#type-rflag">rflag</a> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?rex</span>:<a href="#type-regexp">regexp</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?pat</span>:string <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?pos</span>:int <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?itempl</span>:<a href="#type-substitution">substitution</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?templ</span>:string <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?callout</span>:<a href="#type-callout">callout</a> <span class="arrow">&#45;&gt;</span></span>
  <span>string <span class="arrow">&#45;&gt;</span></span>
  string</span></code></div><div class="spec-doc"><p><code>replace_first ?iflags ?flags ?rex ?pat ?pos ?itempl ?templ ?callout subj</code> replaces the first substring of <code>subj</code> matching pattern <code>pat</code> when given, regular expression <code>rex</code> otherwise, starting at position <code>pos</code> with the substitution string <code>templ</code> when given, <code>itempl</code> otherwise. Uses <code>flags</code> when given, the precompiled <code>iflags</code> otherwise. Callouts are handled by <code>callout</code>.</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">iflags</span> <p>default = no extra flags</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">flags</span> <p>default = ignored</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">rex</span> <p>default = matches whitespace</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">pat</span> <p>default = ignored</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">pos</span> <p>default = 0</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">itempl</span> <p>default = empty string</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">templ</span> <p>default = ignored</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">callout</span> <p>default = ignore callouts</p></li></ul><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <code>Failure</code> <p>if there are backreferences to nonexistent subpatterns.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-qreplace_first"><a href="#val-qreplace_first" class="anchor"></a><code><span><span class="keyword">val</span> qreplace_first : 
  <span><span class="optlabel">?iflags</span>:<a href="#type-irflag">irflag</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?flags</span>:<span><a href="#type-rflag">rflag</a> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?rex</span>:<a href="#type-regexp">regexp</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?pat</span>:string <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?pos</span>:int <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?templ</span>:string <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?callout</span>:<a href="#type-callout">callout</a> <span class="arrow">&#45;&gt;</span></span>
  <span>string <span class="arrow">&#45;&gt;</span></span>
  string</span></code></div><div class="spec-doc"><p><code>qreplace_first ?iflags ?flags ?rex ?pat ?pos ?templ ?callout subj</code> replaces the first substring of <code>subj</code> matching pattern <code>pat</code> when given, regular expression <code>rex</code> otherwise, starting at position <code>pos</code> with the string <code>templ</code>. Uses <code>flags</code> when given, the precompiled <code>iflags</code> otherwise. Callouts are handled by <code>callout</code>.</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">iflags</span> <p>default = no extra flags</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">flags</span> <p>default = ignored</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">rex</span> <p>default = matches whitespace</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">pat</span> <p>default = ignored</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">pos</span> <p>default = 0</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">templ</span> <p>default = ignored</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">callout</span> <p>default = ignore callouts</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-substitute_substrings_first"><a href="#val-substitute_substrings_first" class="anchor"></a><code><span><span class="keyword">val</span> substitute_substrings_first : 
  <span><span class="optlabel">?iflags</span>:<a href="#type-irflag">irflag</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?flags</span>:<span><a href="#type-rflag">rflag</a> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?rex</span>:<a href="#type-regexp">regexp</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?pat</span>:string <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?pos</span>:int <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?callout</span>:<a href="#type-callout">callout</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">subst</span>:<span>(<span><a href="#type-substrings">substrings</a> <span class="arrow">&#45;&gt;</span></span> string)</span> <span class="arrow">&#45;&gt;</span></span>
  <span>string <span class="arrow">&#45;&gt;</span></span>
  string</span></code></div><div class="spec-doc"><p><code>substitute_substrings_first
       ?iflags ?flags ?rex ?pat ?pos ?callout ~subst subj</code> replaces the first substring of <code>subj</code> matching pattern <code>pat</code> when given, regular expression <code>rex</code> otherwise, starting at position <code>pos</code> with the result of function <code>subst</code> applied to the substrings of the match. Uses <code>flags</code> when given, the precompiled <code>iflags</code> otherwise. Callouts are handled by <code>callout</code>.</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">iflags</span> <p>default = no extra flags</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">flags</span> <p>default = ignored</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">rex</span> <p>default = matches whitespace</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">pat</span> <p>default = ignored</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">pos</span> <p>default = 0</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">callout</span> <p>default = ignore callouts</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-substitute_first"><a href="#val-substitute_first" class="anchor"></a><code><span><span class="keyword">val</span> substitute_first : 
  <span><span class="optlabel">?iflags</span>:<a href="#type-irflag">irflag</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?flags</span>:<span><a href="#type-rflag">rflag</a> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?rex</span>:<a href="#type-regexp">regexp</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?pat</span>:string <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?pos</span>:int <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?callout</span>:<a href="#type-callout">callout</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">subst</span>:<span>(<span>string <span class="arrow">&#45;&gt;</span></span> string)</span> <span class="arrow">&#45;&gt;</span></span>
  <span>string <span class="arrow">&#45;&gt;</span></span>
  string</span></code></div><div class="spec-doc"><p><code>substitute_first ?iflags ?flags ?rex ?pat ?pos ?callout ~subst subj</code> replaces the first substring of <code>subj</code> matching pattern <code>pat</code> when given, regular expression <code>rex</code> otherwise, starting at position <code>pos</code> with the result of function <code>subst</code> applied to the match. Uses <code>flags</code> when given, the precompiled <code>iflags</code> otherwise. Callouts are handled by <code>callout</code>.</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">iflags</span> <p>default = no extra flags</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">flags</span> <p>default = ignored</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">rex</span> <p>default = matches whitespace</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">pat</span> <p>default = ignored</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">pos</span> <p>default = 0</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">callout</span> <p>default = ignore callouts</p></li></ul></div></div><h2 id="splitting"><a href="#splitting" class="anchor"></a>Splitting</h2><div class="odoc-spec"><div class="spec value anchored" id="val-split"><a href="#val-split" class="anchor"></a><code><span><span class="keyword">val</span> split : 
  <span><span class="optlabel">?iflags</span>:<a href="#type-irflag">irflag</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?flags</span>:<span><a href="#type-rflag">rflag</a> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?rex</span>:<a href="#type-regexp">regexp</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?pat</span>:string <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?pos</span>:int <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?max</span>:int <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?callout</span>:<a href="#type-callout">callout</a> <span class="arrow">&#45;&gt;</span></span>
  <span>string <span class="arrow">&#45;&gt;</span></span>
  <span>string list</span></span></code></div><div class="spec-doc"><p><code>split ?iflags ?flags ?rex ?pat ?pos ?max ?callout subj</code> splits <code>subj</code> into a list of at most <code>max</code> strings, using as delimiter pattern <code>pat</code> when given, regular expression <code>rex</code> otherwise, starting at position <code>pos</code>. Uses <code>flags</code> when given, the precompiled <code>iflags</code> otherwise. If <code>max</code> is zero, trailing empty fields are stripped. If it is negative, it is treated as arbitrarily large. If neither <code>pat</code> nor <code>rex</code> are specified, leading whitespace will be stripped! Should behave exactly as in PERL. Callouts are handled by <code>callout</code>.</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">iflags</span> <p>default = no extra flags</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">flags</span> <p>default = ignored</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">rex</span> <p>default = matches whitespace</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">pat</span> <p>default = ignored</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">pos</span> <p>default = 0</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">max</span> <p>default = 0</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">callout</span> <p>default = ignore callouts</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-asplit"><a href="#val-asplit" class="anchor"></a><code><span><span class="keyword">val</span> asplit : 
  <span><span class="optlabel">?iflags</span>:<a href="#type-irflag">irflag</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?flags</span>:<span><a href="#type-rflag">rflag</a> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?rex</span>:<a href="#type-regexp">regexp</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?pat</span>:string <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?pos</span>:int <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?max</span>:int <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?callout</span>:<a href="#type-callout">callout</a> <span class="arrow">&#45;&gt;</span></span>
  <span>string <span class="arrow">&#45;&gt;</span></span>
  <span>string array</span></span></code></div><div class="spec-doc"><p><code>asplit ?iflags ?flags ?rex ?pat ?pos ?max ?callout subj</code> same as <a href="#val-split"><code>Pcre.split</code></a> but return an array instead of a list.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-split_result"><a href="#type-split_result" class="anchor"></a><code><span><span class="keyword">type</span> split_result</span><span> = </span></code><ol><li id="type-split_result.Text" class="def variant constructor anchored"><a href="#type-split_result.Text" class="anchor"></a><code><span>| </span><span><span class="constructor">Text</span> <span class="keyword">of</span> string</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Text part of split string</p><span class="comment-delim">*)</span></div></li><li id="type-split_result.Delim" class="def variant constructor anchored"><a href="#type-split_result.Delim" class="anchor"></a><code><span>| </span><span><span class="constructor">Delim</span> <span class="keyword">of</span> string</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Delimiter part of split string</p><span class="comment-delim">*)</span></div></li><li id="type-split_result.Group" class="def variant constructor anchored"><a href="#type-split_result.Group" class="anchor"></a><code><span>| </span><span><span class="constructor">Group</span> <span class="keyword">of</span> int * string</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Subgroup of matched delimiter (subgroup_nr, subgroup_str)</p><span class="comment-delim">*)</span></div></li><li id="type-split_result.NoGroup" class="def variant constructor anchored"><a href="#type-split_result.NoGroup" class="anchor"></a><code><span>| </span><span><span class="constructor">NoGroup</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Unmatched subgroup</p><span class="comment-delim">*)</span></div></li></ol></div><div class="spec-doc"><p>Result of a <a href="#val-full_split"><code>Pcre.full_split</code></a></p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-full_split"><a href="#val-full_split" class="anchor"></a><code><span><span class="keyword">val</span> full_split : 
  <span><span class="optlabel">?iflags</span>:<a href="#type-irflag">irflag</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?flags</span>:<span><a href="#type-rflag">rflag</a> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?rex</span>:<a href="#type-regexp">regexp</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?pat</span>:string <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?pos</span>:int <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?max</span>:int <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?callout</span>:<a href="#type-callout">callout</a> <span class="arrow">&#45;&gt;</span></span>
  <span>string <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-split_result">split_result</a> list</span></span></code></div><div class="spec-doc"><p><code>full_split ?iflags ?flags ?rex ?pat ?pos ?max ?callout subj</code> splits <code>subj</code> into a list of at most <code>max</code> elements of type &quot;split_result&quot;, using as delimiter pattern <code>pat</code> when given, regular expression <code>rex</code> otherwise, starting at position <code>pos</code>. Uses <code>flags</code> when given, the precompiled <code>iflags</code> otherwise. If <code>max</code> is zero, trailing empty fields are stripped. If it is negative, it is treated as arbitrarily large. Should behave exactly as in PERL. Callouts are handled by <code>callout</code>.</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">iflags</span> <p>default = no extra flags</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">flags</span> <p>default = ignored</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">rex</span> <p>default = matches whitespace</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">pat</span> <p>default = ignored</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">pos</span> <p>default = 0</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">max</span> <p>default = 0</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">callout</span> <p>default = ignore callouts</p></li></ul></div></div><h2 id="additional-convenience-functions"><a href="#additional-convenience-functions" class="anchor"></a>Additional convenience functions</h2><div class="odoc-spec"><div class="spec value anchored" id="val-foreach_line"><a href="#val-foreach_line" class="anchor"></a><code><span><span class="keyword">val</span> foreach_line : <span><span class="optlabel">?ic</span>:<span class="xref-unresolved">Stdlib</span>.in_channel <span class="arrow">&#45;&gt;</span></span> <span><span>(<span>string <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>foreach_line ?ic f</code> applies <code>f</code> to each line in inchannel <code>ic</code> until the end-of-file is reached.</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">ic</span> <p>default = stdin</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-foreach_file"><a href="#val-foreach_file" class="anchor"></a><code><span><span class="keyword">val</span> foreach_file : <span><span>string list</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span>string <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Stdlib</span>.in_channel <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>foreach_file filenames f</code> opens each file in the list <code>filenames</code> for input and applies <code>f</code> to each filename and the corresponding channel. Channels are closed after each operation (even when exceptions occur - they get reraised afterwards!).</p></div></div><h2 id="unsafe-stuff---use-with-caution!"><a href="#unsafe-stuff---use-with-caution!" class="anchor"></a><b>UNSAFE STUFF - USE WITH CAUTION!</b></h2><div class="odoc-spec"><div class="spec value anchored" id="val-unsafe_pcre_exec"><a href="#val-unsafe_pcre_exec" class="anchor"></a><code><span><span class="keyword">val</span> unsafe_pcre_exec : 
  <span><a href="#type-irflag">irflag</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-regexp">regexp</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">pos</span>:int <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">subj_start</span>:int <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">subj</span>:string <span class="arrow">&#45;&gt;</span></span>
  <span><span>int array</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><a href="#type-callout">callout</a> option</span> <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div><div class="spec-doc"><p><code>unsafe_pcre_exec flags rex ~pos ~subj_start ~subj offset_vector callout</code>. You should read the C-source to know what happens. If you do not understand it - <b>don't use this function!</b></p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-make_ovector"><a href="#val-make_ovector" class="anchor"></a><code><span><span class="keyword">val</span> make_ovector : <span><a href="#type-regexp">regexp</a> <span class="arrow">&#45;&gt;</span></span> int * <span>int array</span></span></code></div><div class="spec-doc"><p><code>make_ovector regexp</code> calculates the tuple (subgroups2, ovector) which is the number of subgroup offsets and the offset array.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-unsafe_pcre_dfa_exec"><a href="#val-unsafe_pcre_dfa_exec" class="anchor"></a><code><span><span class="keyword">val</span> unsafe_pcre_dfa_exec : 
  <span><a href="#type-irflag">irflag</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-regexp">regexp</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">pos</span>:int <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">subj_start</span>:int <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">subj</span>:string <span class="arrow">&#45;&gt;</span></span>
  <span><span>int array</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><a href="#type-callout">callout</a> option</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">workspace</span>:<span>int array</span> <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div><div class="spec-doc"><p><code>unsafe_pcre_dfa_exec flags rex ~pos ~subj_start ~subj offset_vector callout
    ~workpace</code>. You should read the C-source to know what happens. If you do not understand it - <b>don't use this function!</b></p></div></div></div></body></html>
